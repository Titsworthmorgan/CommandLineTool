# Description
This is a simple command line tool written in C++ that processes command line arguments and performs basic operations based on the provided flags.
I am not going to have this add to the path or even try to facilitate this working system wide for the final, it is just a simple tool for learning and experimentation.
I saw this project on https://codingchallenges.fyi/challenges/challenge-wc, and figured it would be more practical than a ascii art frogger game.
This may be expanded into something like a json parser or, who knows, but for the scope of the final it will be a simple word/line/byte counter first.
Anything additional will require specific flags to be passed in and potentially return debug information if not validated against all test cases. 
(as many as I can remember or find online at least)

# Features
- Character counter (to be added)
- Byte counter
- Line counter
- Word counter
- JSON formatter (basic functionality)

# System and Compiler
- Developed and tested on Linux and Windows
- Compiled with g++ (GNU Compiler Collection)

# Compilation Instructions
There are two shell scripts provided for compiling the project:
1. `build.sh`: For building the project and generating the executable.
2. `test.sh`: For testing the compiled executable.

# Usage Instructions
To use the command line tool, run the executable with the desired options. Below are the available options:
1. Run `test.sh -[flag] [fileName.Example] [outputFileName.Example]` to output the desired count based on the flag provided.

2. Navigate to the directory containing the executable and run `./your_executable_name -[flag] [fileName.Example] [outputFileName.Example]`.
    - Note: This will vary based on where you have your desired file located. You may need to specify the full path to the file.

3. For the project scope the following will be what we use:
    - `-h`: Displays help information about the tool.
    - `-c`: outputs number of bytes in a file
    - `-l`: outputs number of lines in a file
    - `-w`: outputs number of words in a file
    - `-j`: formats input JSON file to be more human-readable in duplicate file with -formatted.json suffix - works... mostly for now.

## Available Options:
- `-h`: Displays help information about the tool.
- `-c`: outputs number of bytes in a file
- `-l`: outputs number of lines in a file
- `-w`: outputs number of words in a file
- `-j`: formats input JSON file to be more human-readable in duplicate file with -formatted.json suffix.

# Project Structure
- `src/`: Contains the source code files.
- `output/`: Directory for output files generated by the tool.
- `testing/`: Contains test input files for the tool.
- `submission/`: Directory for final project submission files.
- `.clang-format`: Configuration file for code formatting, this was honestly just breaking my brain a bit reading the syntax so I googled how to make the syntax a little more comfortable for me personally. For project submission the default will be used.
- `test.sh`: Shell script for testing the executable. (both this and build.sh are purely for convenience)
- `build.sh`: Shell script for building the project. 


# Testing
Testing I am looking to generate as many different pass/fail cases as I can think of or find online.
For this I have a BOAT LOAD of extra ERD's that could be put into 'real-word' scenarios or, at least ones I've used in the past for work without sharing any proprietary information.
The main focus of testing for now will be on the JSON formatting functionality as that is the most complex feature of the tool so far.
As of 2025/12/01 testing is 'done' for the word/line/byte counting features aside from the characters counting which, as I'm typing realized I missed.

## WC Standards
For now I'm working to follow these standards:
https://pubs.opengroup.org/onlinepubs/9799919799/ - The Open Group Base Specifications Issue 7, 2018 edition - wc(1) - word, line, byte, and character count
I am going to try my best to follow these guidelines for the word/line/byte counting features. Right now my base test is on `The Project Gutenberg eBook of The Art of War`
in .txt format.
For now the only thing I'm really worried about is:
1. Can it handle large files? (they should all be TXT files for this)
2. Does it count chars/lines/words/bytes correctly as per the standard?
3. Does it handle edge cases like empty files, files with only whitespace, etc.?

## JSON Standards

For now I'm working with these two standards: 
https://www.rfc-editor.org/rfc/pdfrfc/rfc8259.txt.pdf - The JavaScript Object Notation (JSON) Data Interchange Format
https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf - The JSON Data Interchange Standard

### Testing Outline

1. Generate test json files, fail{num}.json EG: fail1.json, fail2.json, etc. with specific errors in them.
2. Generate test json files, pass{num}.json EG: pass1.json, pass2.json, etc. that are valid json files.
3. Run the tool against each file and verify the output is as expected.
4. Fix bugs as they appear and re-test until all tests pass.