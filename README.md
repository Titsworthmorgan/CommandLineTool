# Description
This is a simple command line tool written in C++ that processes command line arguments and performs basic operations based on the provided flags.
I am not going to have this add to the path or even try to facilitate this working system wide for the final, it is just a simple tool for learning and experimentation.
I saw this project on https://codingchallenges.fyi/challenges/challenge-wc, and figured it would be more practical than a ascii art frogger game.
This may be expanded into something like a json parser or, who knows, but for the scope of the final it will be a simple word/line/byte counter first.
Anything additional will require specific flags to be passed in and potentially return debug information if not validated against all test cases. 
(as many as I can remember or find online at least)

### Notes
- I wanted to put the JSON formatter into two classes.
    - One for lexical analysis (tokenizing)
    - One for parsing and formatting
- I used: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently
as a guide for when to use struct vs class in C++. I also did a bunch of other digging and deduced that classes should be declared in header files and their methods defined in cpp files.
- Testing I just grabbed the two most official looking JSON standards I could find online and made test cases based on those.
    - https://www.rfc-editor.org/rfc/pdfrfc/rfc8259.txt.pdf - The JavaScript Object Notation (JSON) Data Interchange Format
    - https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf - The JSON Data Interchange Standard
- I started with using a some old entity relation diagrams I used previously for work, and generate dummy data JSON based on those to use as test cases.

# Features
- Character counter (to be added)
- Byte counter
- Line counter
- Word counter
- JSON formatter (basic functionality)
- JSON testing

# System and Compiler
- Developed and tested on Linux and Windows
- Compiled with g++ (GNU Compiler Collection)

# Compilation Instructions
There are two shell scripts provided for compiling the project, because typing everything as many times as was needed was a no go.
1. `build.sh`: For building the project and generating the executable.
2. `test.sh`: For testing the compiled executable.

# Usage Instructions
To use the command line tool, run the executable with the desired options. Below are the available options:
1. Run `test.sh -[flag] [fileName.Example] [outputFileName.Example]` to output the desired count based on the flag provided.

2. Navigate to the directory containing the executable and run `./your_executable_name -[flag] [fileName.Example] [outputFileName.Example]`.
    - Note: This will vary based on where you have your desired file located. You may need to specify the full path to the file.

3. For the final project the following will be what we use:
    - `-h`: Displays help information about the tool.
    - `-c`: outputs number of bytes in a file
    - `-f`: outputs number of characters in a file
    - `-l`: outputs number of lines in a file
    - `-w`: outputs number of words in a file\
    - `-a`: outputs all of the above counts in a single run
    - `-j`: formats input JSON file to be more human-readable in duplicate file with -formatted.json suffix - works... mostly.
    - `-t`: tests all of the JSON test cases according to the standards found online

## Available Options:
- `-h`: Displays help information about the tool.
- `-c`: outputs number of bytes in a file
- `-f`: outputs number of characters in a file
- `-l`: outputs number of lines in a file
- `-w`: outputs number of words in a file
- `-j`: formats input JSON file to be more human-readable in duplicate file with -formatted.json suffix.
- `-t`: tests all of the JSON test cases according to the standards found online

# Project Structure
- `src/`: Contains the source code files.
- `output/`: Directory for output files generated by the tool.
- `testing/`: Contains test input files for the tool.
- `submission/`: Directory for final project submission files.
- `.clang-format`: Configuration file for code formatting
- `test.sh`: Shell script for testing the executable.
- `build.sh`: Shell script for building the project. 


# Testing
Testing I am looking to generate as many different pass/fail cases as I can think of or find online.
For this I have a BOAT LOAD of extra ERD's that could be put into 'real-word' scenarios or, at least ones I've used in the past for work without sharing any proprietary information.
The main focus of testing for now will be on the JSON formatting functionality as that is the most complex feature of the tool so far.

## WC Standards
For now I'm working to follow these standards:
https://pubs.opengroup.org/onlinepubs/9799919799/ - The Open Group Base Specifications Issue 7, 2018 edition - wc(1) - word, line, byte, and character count
I am going to try my best to follow these guidelines for the word/line/byte counting features. Right now my base test is on `The Project Gutenberg eBook of The Art of War`
in .txt format.
For now the only thing I'm really worried about is:
1. Can it handle large files? (they should all be TXT files for this)
2. Does it count chars/lines/words/bytes correctly as per the standard?
3. Does it handle edge cases like empty files, files with only whitespace, etc.?

## JSON Standards

For now I'm working with these two standards: 
https://www.rfc-editor.org/rfc/pdfrfc/rfc8259.txt.pdf - The JavaScript Object Notation (JSON) Data Interchange Format
https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf - The JSON Data Interchange Standard

### Test Cases for JSON Formatting

Each test case has a fail*.json (invalid) and pass*.json (valid) pair. Pass conditions are based on RFC 8259 and ECMA-404 standards:

1. **fail1/pass1 - Trailing Commas**
   - Pass Condition: No trailing commas allowed after last element in arrays or objects
   - Regulation: RFC 8259 Section 5 & 6 - arrays and objects must not have trailing commas -->

2. **fail2/pass2 - String Delimiters**
   - Pass Condition: Strings must use double quotes (") only, not single quotes (')
   - Regulation: RFC 8259 Section 7 - strings must be enclosed in quotation marks (U+0022)

3. **fail3/pass3 - Object Key Quoting**
   - Pass Condition: All object keys must be quoted strings
   - Regulation: RFC 8259 Section 4 - object member names must be strings (quoted)

4. **fail4/pass4 - Comments** 
   - Pass Condition: No comments allowed (// or /* */)
   - Regulation: RFC 8259 - JSON grammar does not include comments

5. **fail5/pass5 - Primitive Values**
   - Pass Condition: Only true, false, null allowed as literals (no undefined, NaN, Infinity)
   - Regulation: RFC 8259 Section 3 - valid values are object, array, number, string, true, false, null

6. **fail6/pass6 - Nesting Depth**
   - Pass Condition: Reasonable nesting depth (implementation-dependent, typically 20-100 levels max)
   - Regulation: RFC 8259 Section 9 - parsers may set limits on nesting depth to avoid stack overflow

7. **fail7/pass7 - Escape Sequences**
   - Pass Condition: Only valid escape sequences: \", \\, \/, \b, \f, \n, \r, \t, \uXXXX
   - Regulation: RFC 8259 Section 7 - defines valid escape sequences, \x is not valid

8. **fail8/pass8 - Number Formatting**
   - Pass Condition: No leading zeros (except for 0.x), no hex/octal notation
   - Regulation: RFC 8259 Section 6 - numbers cannot have leading zeros, must be decimal

9. **fail9/pass9 - String Termination**
   - Pass Condition: All strings must be properly closed with ending quotation mark
   - Regulation: RFC 8259 Section 7 - strings must begin and end with quotation marks

10. **fail10/pass10 - Bracket Matching**
    - Pass Condition: Opening brackets [ must match with ], { must match with }
    - Regulation: RFC 8259 Sections 5 & 6 - proper structural tokens required

11. **fail11/pass11 - Duplicate Keys**
    - Pass Condition: Object keys should be unique (behavior of duplicates is undefined)
    - Regulation: RFC 8259 Section 4 - duplicate names within an object are discouraged

12. **fail12/pass12 - Array Trailing Comma**
    - Pass Condition: No comma after last array element
    - Regulation: RFC 8259 Section 5 - array values separated by commas, no trailing comma

13. **fail13/pass13 - Structure Completion**
    - Pass Condition: All opened braces/brackets must be closed
    - Regulation: RFC 8259 Section 2 - JSON text must be a complete structure

14. **fail14/pass14 - Number Sign**
    - Pass Condition: Positive numbers have no sign prefix, negative use minus only (no plus sign)
    - Regulation: RFC 8259 Section 6 - optional minus, no plus sign defined

15. **fail15/pass15 - Control Characters**
    - Pass Condition: Control characters (U+0000 to U+001F) must be escaped in strings
    - Regulation: RFC 8259 Section 7 - control characters must be escaped

### Testing Outline

1. Generate test json files, fail{num}.json EG: fail1.json, fail2.json, etc. with specific errors in them.
2. Generate test json files, pass{num}.json EG: pass1.json, pass2.json, etc. that are valid json files.
3. Run the tool against each file and verify the output is as expected.
4. Fix bugs as they appear and re-test until all tests pass.
5. Generate testFinal.json that is a large JSON file with all expected passing features and run the tool against it to ensure it can handle larger files/output the corrrectly formatted version.